<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ali]]></title>
  <link href="http://spiritbook.github.com/atom.xml" rel="self"/>
  <link href="http://spiritbook.github.com/"/>
  <updated>2013-09-18T23:25:48+08:00</updated>
  <id>http://spiritbook.github.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux-thread-priority]]></title>
    <link href="http://spiritbook.github.com/blog/2013/09/18/linux-thread-priority/"/>
    <updated>2013-09-18T22:50:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2013/09/18/linux-thread-priority</id>
    <content type="html"><![CDATA[<h2>1. Linux线程优先级范围</h2>

<p>Linux定义线程优先级范围在头文件&lt;linux/sched.h></br></p>

<pre><code>/*
 * Priority of a process goes from 0..MAX_PRIO-1, valid RT
 * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH
 * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority
 * values are inverted: lower p-&gt;prio value means higher priority.
 *
 * The MAX_USER_RT_PRIO value allows the actual maximum
 * RT priority to be separate from the value exported to
 * user-space.  This allows kernel threads to set their
 * priority to a value higher than any user task. Note:
 * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
 */

#define MAX_USER_RT_PRIO    100
#define MAX_RT_PRIO         MAX_USER_RT_PRIO

#define MAX_PRIO            (MAX_RT_PRIO + 40)
#define DEFAULT_PRIO        (MAX_RT_PRIO + 20)
</code></pre>

<h2>2 查看线程优先级</h2>

<h3>1 top命令</h3>

<pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                          
    1 root      20   0  2804 1576 1192 S  0.0  0.3   0:00.97 init                                                                           
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd                                                                       
    3 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0                                                                    
    4 root      20   0     0    0    0 S  0.0  0.0   0:00.02 ksoftirqd/0                                                                    
    5 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 watchdog/0                                                                     
    6 root      20   0     0    0    0 S  0.0  0.0   0:00.06 events/0     
</code></pre>

<p>PR 和 NI 从 proc文件系统中读取得到 &#8220;/proc/[pid]/stat&#8221;<br></p>

<pre><code>cat /proc/1/stat
1 (init) S 0 1 1 0 -1 4202752 4680 154640 23 343 6 136 154 151 20 0 ...
cat /proc/3/stat
3 (migration/0) S 2 0 0 0 -1 2216730688 0 0 0 0 0 0 0 0 -100 0  ...
priority %ld
</code></pre>

<p>man proc stat 查看第18项和第19项的说明<br></p>

<pre><code>(18) (Explanation for Linux 2.6) For processes running a real-time scheduling policy (policy below; see sched_setscheduler(2)), 
this is the negated scheduling priority, minus one; that is, a number in the range -2 to -100, corresponding to real-time priorities 1 to 99. 
For processes running under a non-real-time scheduling policy, this is the raw nice value (setpriority(2)) as represented in the kernel. 
The kernel stores nice values as numbers in the range 0 (high) to 39 (low), corresponding to the user-visible nice range of -20 to 19.

Before Linux 2.6, this was a scaled value based on the scheduler weighting given to this process.

nice %ld
(19) The nice value (see setpriority(2)), a value in the range 19 (low priority) to -20 (high priority).
</code></pre>

<h3>2 ps命令</h3>

<pre><code>c@c-desktop:~$ ps -el
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 -   702 poll_s ?        00:00:01 init
1 S     0     2     0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd
1 S     0     3     2  0 -40   - -     0 migrat ?        00:00:00 migration/0
1 S     0     4     2  0  80   0 -     0 ksofti ?        00:00:00 ksoftirqd/0
5 S     0     5     2  0 -40   - -     0 watchd ?        00:00:00 watchdog/0
1 S     0     6     2  0  80   0 -     0 worker ?        00:00:00 events/0
</code></pre>

<p>这里的PRI为什么和top的PRI不一样呢，通过查看procps源代码找到了原因<br></p>

<pre><code>In linux procps, the column labeled "PRI" in ps -l is -o opri
c@c-desktop:~$ ps -e -o pid,pri,opri,intpri,priority,ni,cmd
  PID PRI PRI PRI PRI  NI CMD
    1  19  80  80  20   0 /sbin/init
    2  19  80  80  20   0 [kthreadd]
    3 139 -40 -40 -100  - [migration/0]
    4  19  80  80  20   0 [ksoftirqd/0]
    5 139 -40 -40 -100  - [watchdog/0]
    6  19  80  80  20   0 [events/0]
</code></pre>

<p>procps/output.c中含有具体说明<br></p>

<pre><code>// "priority"         (was -20..20, now -100..39)
// "intpri" and "opri" (was 39..79, now  -40..99)
// "pri_foo"   --  match up w/ nice values of sleeping processes (-120..19)
// "pri_bar"   --  makes RT pri show as negative       (-99..40)
// "pri_baz"   --  the kernel's -&gt;prio value, as of Linux 2.6.8     (1..140)
// "pri"               (was 20..60, now    0..139)
// "pri_api"   --  match up w/ RT API    (-40..99)
</code></pre>

<h2>3. Reference</h2>

<p>(1) <a href="http://superuser.com/questions/286752/unix-ps-l-priority">http://superuser.com/questions/286752/unix-ps-l-priority</a><br>
(2) <a href="http://procps.sourceforge.net/download.html">http://procps.sourceforge.net/download.html</a> 需要翻墙</p>

<p>Author: chenxiawei@gmail.com<br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Linux]X86-32函数调用过程堆栈]]></title>
    <link href="http://spiritbook.github.com/blog/2013/06/01/x86-bt/"/>
    <updated>2013-06-01T22:32:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2013/06/01/x86-bt</id>
    <content type="html"><![CDATA[<h2>1. 测试代码如下，下文的分析基于该代码</h2>

<pre><code>  1 #include &lt;stdio.h&gt;
  2
  3 void func_b(int va, int vb)
  4 {
  5     int vc;
  6
  7     vc = va + vb;
  8 }
  9
 10 void func_a(void)
 11 {
 12     int va = 2, vb = 3;
 13     func_b(va, vb);
 14 }
 15
 16 int main(void)
 17 {
 18     func_a();
 19
 20     return 0;
 21 }
 使用gdb，断点
</code></pre>

<h2>2 查看当前进程寄存器信息</h2>

<pre><code>(gdb) info reg  
eax            0x5      5                       //&lt;--- 累加器
ecx            0x6cb4f478       1823798392      //&lt;--- 计数寄存器
edx            0x2      2                       //&lt;--- 数据寄存器
ebx            0x283ff4 2637812                 //&lt;--- 基址寄存器
esp            0xbffff750       0xbffff750      //&lt;--- 堆栈指针寄存器
ebp            0xbffff760       0xbffff760      //&lt;--- 基指针寄存器
esi            0x0      0                       //&lt;--- 变址寄存器
edi            0x0      0                       //&lt;--- 变址寄存器
eip            0x80483c6        0x80483c6 &lt;func_b+18&gt; //&lt;--- 指令指针寄存器
eflags         0x200286 [ PF SF IF ID ]         //&lt;--- 标志寄存器
cs             0x73     115                     //&lt;--- 代码段寄存器
ss             0x7b     123                     //&lt;--- 堆栈段寄存器
ds             0x7b     123                     //&lt;--- 数据段寄存器
es             0x7b     123                     //&lt;--- 附加段寄存器
fs             0x0      0                       //&lt;--- 附加段寄存器
gs             0x33     51                      //&lt;--- 附加段寄存器
</code></pre>

<h2>3. 函数调用过程及栈空间信息</h2>

<p>(1). 将函数参数从右至左入栈。<br>
(2). 函数指针入栈，调用函数。<br>
(3). ebp指针入栈。<br>
(4). 函数局部变量从前至后入栈。<br></p>

<pre><code>high 
    | 。。。           |
    | 返回地址(main)   |
    | 上一层ebp地址    |      
    | 局部变量va       | &lt;---- 局部变量从前至后压栈
    | 局部变量vb       | 
    | 。。。           |
    | 参数vb           | &lt;---- 函数形参按照从右至左压栈
    | 参数va           |
    | 返回地址(func_a) | &lt;---- eip 地址
    | 上一层ebp地址    | &lt;---- ebp 地址
    | 局部变量vc       | 
    | 。。。           | &lt;---- esp 栈顶指针
low
</code></pre>

<h2>4. 查看从栈顶指针esp后的一段连续地址空间内容</h2>

<pre><code>(gdb) x/14x 0xbffff750 
0xbffff750:     0x0011e030      
0xbffff754:     0x08049ff4
0xbffff758:     0xbffff788
0xbffff75c:     0x00000005  //&lt;------ func_b函数的局部变量vc
0xbffff760:     0xbffff780  //&lt;------ 保存上一层函数ebp的地址，用于回溯
0xbffff764:     0x080483ee  //&lt;------ 保存上一层函数eip的值，即为上一层函数指针地址，这里为func_a
0xbffff768:     0x00000002  //&lt;------ 保存当前函数的参数，这里为func_b函数的va
0xbffff76c:     0x00000003  //&lt;------ 保存当前函数的参数，这里为func_b函数的vb
0xbffff770:     0x0015d4a5 
0xbffff774:     0x0011e030
0xbffff778:     0x00000003  //&lt;------ func_a函数的局部变量vb
0xbffff77c:     0x00000002  //&lt;------ func_a函数的局部变量va
0xbffff780:     0xbffff788  //&lt;------ 保存上一层函数ebp的地址，用于回溯
0xbffff784:     0x080483f8  //&lt;------ 保存上一层函数eip的值，即为上一层函数指针地址，这里为main
</code></pre>

<h2>5. 通过反汇编来了解函数压栈过程</h2>

<p>使用命令objdump xxx.elf -d 生成汇编代码</p>

<pre><code>080483b4 &lt;func_b&gt;: //&lt;------ 到这里时 esp=0xbffff764 ebp=0xbffff780
80483b4:        push   %ebp                   //ebp压栈，把0xbffff780压入[0xbffff760]，
                                                并且调整栈顶指针esp - 0x4 = 0xbffff760
80483b5:        mov    %esp,%ebp              //保存栈顶指针esp至ebp ，ebp=0xbffff760
80483b7:        sub    $0x10,%esp             //调整栈顶指针esp, esp - 0x10 = 0xbffff750
80483ba:        mov    0xc(%ebp),%eax         //取[ebp + 0xc] = [0xbffff76b]位置的vb=3赋值给eax
80483bd:        mov    0x8(%ebp),%edx         //取[ebp + 0x8] = [0xbffff768]位置的va=2赋值给edx
80483c0:        lea    (%edx,%eax,1),%eax     //计算 eax = eax + edx
80483c3:        mov    %eax,-0x4(%ebp)        //将vc=5放入局部变量地址[ebp - 4] = [0xbffff75b]
80483c6:        leave  
80483c7:        ret    

080483c8 &lt;func_a&gt;: //&lt;------ 到这里时 esp=0xbffff784 ebp=0xbffff788
80483c8:        push   %ebp                   //ebp压栈，即将值0xbffff788写入地址[0xbffff780]，
                                                并且调整栈顶指针esp - 0x4 = 0xbffff780
80483c9:        mov    %esp,%ebp              //保存栈顶指针esp至ebp，ebp=0xbffff780
80483cb:        sub    $0x18,%esp             //调整栈顶指针esp，esp - 0x18 = 0xbffff768
80483ce:        movl   $0x2,-0x4(%ebp)        //局部变量压栈，ebp-4位置赋值为va=2，
                                                即将值2写入地址[0xbffff77b]位置
80483d5:        movl   $0x3,-0x8(%ebp)        //局部变量压栈，ebp-8位置赋值为vb=3，
                                                即将值3写入地址[0xbffff778]位置
80483dc:        mov    -0x8(%ebp),%eax        //eax = 3
80483df:        mov    %eax,0x4(%esp)         //形参从右至左压栈，
                                                即将vb=3的值写入地址[esp + 0x4] =[0xbffff76b]位置
80483e3:        mov    -0x4(%ebp),%eax        //eax = 2
80483e6:        mov    %eax,(%esp)            //形参从右至左压栈，
                                                即将vb=2的值写入地址[esp] = [0xbffff768]位置
80483e9:        call   80483b4 &lt;func_b&gt;       //将eip压栈，即将值0x080483ee写入地址[0xbffff764], 
                                                并且调整栈顶指针esp - 0x4 = 0xbffff780，然后调用函数func_b
80483ee:        leave  
80483ef:        ret    
</code></pre>

<h2>6. 利用ebp寄存器实现完整栈回溯信息</h2>

<p>可用于gdb调试时backtrace显示为??导致无法获取回溯信息的情况。</p>

<h2>7. 待分析</h2>

<h3>(1) 函数调用中sub $0x18,%esp的 $0x18是如何计算出</h3>

<p>X86函数局部变量需要16Bytes对齐，func_a的局部变量为8Bytes，向上对齐到0x10。<br>
加上函数参数压栈的va及vb的8Bytes。<br>
<a href="http://stackoverflow.com/questions/612443/why-does-the-mac-abi-require-16-byte-stack-alignment-for-x86-32">http://stackoverflow.com/questions/612443/why-does-the-mac-abi-require-16-byte-stack-alignment-for-x86-32</a></p>

<h3>(2) 栈空间中未在汇编指令中出现的未知值如何生成的</h3>

<p>由于局部变量对齐产生的缝隙，应该是为未指定的变量，每次结果不一定一样。</p>

<h2>8.参考链接</h2>

<p>(1) X86寄存器 <a href="http://www.eecg.toronto.edu/~amza/www.mindsec.com/files/x86regs.html">http://www.eecg.toronto.edu/~amza/www.mindsec.com/files/x86regs.html</a><br>
(2) 《程序员的自我修养-链接、装载与库》10.2节<br>
(3) <a href="http://devpit.org/wiki/x86ManualBacktrace">http://devpit.org/wiki/x86ManualBacktrace</a><br>
(4) wiki <a href="http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames">http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames</a><br></p>

<p>Author: chenxiawei@gmail.com<br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux调试手段]]></title>
    <link href="http://spiritbook.github.com/blog/2013/05/29/linux-debug-skill/"/>
    <updated>2013-05-29T21:19:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2013/05/29/linux-debug-skill</id>
    <content type="html"><![CDATA[<h2>1. 使用gdb</h2>

<p>编译时，使用-g 参数把调试信息（函数名、变量名）加到可执行文件中。</p>

<h3>1.1 启动GDB的方法：</h3>

<pre><code>    (1)、gdb &lt;program&gt;       调试&lt;program&gt; 
    (2)、gdb &lt;program&gt; core  调试&lt;program&gt;生成的core文件
    (3)、gdb &lt;program&gt; &lt;PID&gt; 调试运行时的&lt;program&gt;
</code></pre>

<h3>1.2 常用GDB命令:</h3>

<pre><code>    (1)、print [/&lt;fmt&gt;] &lt;expr&gt; (简写p) 显示指定表达式的内容
            &lt;expr&gt; 显示的表达式。可以为全局变量、局部变量、数组名等。
            &lt;fmt&gt;  显示的格式。x 为十六进制格式，c 为字符格式等。

    (2)、examine [/&lt;len&gt;/&lt;fmt&gt;/&lt;step&gt;] &lt;addr&gt; (简写x) 显示指定地址内容
            &lt;addr&gt; 显示的内存地址的起始地址
            &lt;len&gt; 显示内存的长度
            &lt;fmt&gt; 显示格式。s 为字符串，x 为十六进制。(缺省为十六进制)
            &lt;step&gt; 表示一次显示的字节数。b为单字，h为双字，w为四字。(缺省为四字)

    (3)、thread &lt;id&gt; 切换到指定线程
            &lt;id&gt; 线程编号

    (4)、frame &lt;id&gt; 切换到线程中的指定层次的函数
            &lt;id&gt; 函数层次

    (5)、backtrace [full] 显示当前线程整个栈回溯信息

    (6)、thread apply all backtrace [full] 显示所有线程的栈回溯信息

    (7)、info reg 查看当前寄存器信息    

    (8)、info symbol &lt;addr&gt; 显示函数地址对应的函数名
            &lt;addr&gt; 为函数指针地址 
</code></pre>

<p><a href="https://github.com/spiritbook/helloworld/blob/master/xdebug/xsample1.c">GDB使用例子1&#8211;>戳这里</a></p>

<h2>2. 使用/proc文件系统</h2>

<h3>2.1 查看线程陷入在内核中的栈回溯信息：</h3>

<pre><code>    cat /proc/&lt;pid&gt;/stack
</code></pre>

<p>此方法也适用于查看内核线程当前的栈回溯信息</p>

<h3>2.2 通过内核函数指针值查找对应函数名：</h3>

<pre><code>    cat /proc/kallsyms | grep &lt;addr&gt;
    说明：addr 不需要以0x开头
</code></pre>

<h2>3. 使用反汇编</h2>

<p>TODO</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译时判断系统32位/64位]]></title>
    <link href="http://spiritbook.github.com/blog/2012/10/14/check-64bit/"/>
    <updated>2012-10-14T21:33:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/10/14/check-64bit</id>
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/1505582/determining-32-vs-64-bit-in-c">http://stackoverflow.com/questions/1505582/determining-32-vs-64-bit-in-c</a></p>

<pre><code>#include &lt;limits.h&gt;
#if ((ULONG_MAX) == (UINT_MAX))
 #define CPU_BITS 32
#else
 #define CPU_BITS 64
#endif
</code></pre>

<p>进入&lt;limits.h>看代码，定义如下：</p>

<pre><code>/* Minimum and maximum values a `signed long int' can hold.  */
#  if __WORDSIZE == 64
#   define LONG_MAX     9223372036854775807L
#  else
#   define LONG_MAX     2147483647L
#  endif
</code></pre>

<p>而__WORDSIZE 又是定义在：</p>

<pre><code>#include &lt;bits/wordsize.h&gt;
</code></pre>

<p>可以看到&lt;bits/wordsize.h>在不同体系中是不同的结构
例如x86中：</p>

<pre><code>#if defined __x86_64__
# define __WORDSIZE     64
# define __WORDSIZE_COMPAT32     1
#else
# define __WORDSIZE     32
#endif
</code></pre>

<p>而mips中：</p>

<pre><code>#define __WORDSIZE     _MIPS_SZPTR
#if _MIPS_SIM == _ABI64
# define __WORDSIZE_COMPAT32     1
#endif
</code></pre>

<p>因此最简单的方法是使用</p>

<pre><code>#include &lt;limits.h&gt;
 #define CPU_BITS __WORDSIZE
</code></pre>

<p>或者直接使用宏__WORDSIZE来使用。</p>

<p>注意：不可以使用sizeof来进行预编译时判断
例如 使用</p>

<pre><code>#if sizeof(long) == 8
</code></pre>

<p>来判断是否是64位系统。<br>
因为在编译时会出现编译错误：<br>
error: missing binary operator before token &#8220;(&#8221;<br>
因为#if 是在预编译时期进行，而sizeof是在编译时期进行。<br>
Because sizeof is evaluated at compilation time while directives are evaluated before compilation, and the part that does that is not the compiler, so it won&#8217;t understand what sizeof means.<br>
<a href="http://stackoverflow.com/questions/1612322/why-cant-i-use-sizeof-in-a-preprocessor-condition">http://stackoverflow.com/questions/1612322/why-cant-i-use-sizeof-in-a-preprocessor-condition</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Art of Readable Code (1)]]></title>
    <link href="http://spiritbook.github.com/blog/2012/08/27/readable-code-1/"/>
    <updated>2012-08-27T04:05:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/08/27/readable-code-1</id>
    <content type="html"><![CDATA[<p>“你的代码首先是为人写的，其次才是为计算机写的。”</p>

<h2>1. 代码的写法应当使别人理解它所需的时间最小化。</h2>

<p>Code should be written to minimize the time it would take for someone else to understand it.</p>

<h3>(1) 选择专业的词 (Choose Specific Words)</h3>

<pre><code>GetPage();
DownloadPage();
例如希望构造一个表达下载页面的函数，使用Download比Get更专业
</code></pre>

<p>send  可替换为 deliver, dispatch, announce, distribute, route <br>
find  可替换为 search, extract, locate, recover <br>
start 可替换为 launch, create, begin, open <br>
make  可替换为 create, set up, build, generate, compose, add, new <br></p>

<h3>(2) 避免像tmp和retval这样泛泛的名字 (Avoid generic names)</h3>

<pre><code>for (var i = 0; i &lt; v.length; i += 1) retval += v[i] * v[i];
for (var i = 0; i &lt; v.length; i += 1) sum_squares += v[i] * v[i];
使用sum_squares能更直观地看出变量的含义。
</code></pre>

<h3>(3) 为名字附带更多信息 (Attach important details)</h3>

<pre><code>delay(int delay);
delay(int delay_ms);
通过添加单位，变量delay_ms就比变量delay含义更清晰。
</code></pre>

<h3>(4) 使用不会被误解的名字 (Names That Can’t Be Misconstrued)</h3>

<pre><code>CART_TOO_BIG_LIMIT = 10 
MAX_ITEMS_IN_CART = 10
最大值，则以MAX_、最小值以MIN_ 开头则不容易被误解其含义。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核printk打印特殊内容]]></title>
    <link href="http://spiritbook.github.com/blog/2012/08/19/prink/"/>
    <updated>2012-08-19T22:33:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/08/19/prink</id>
    <content type="html"><![CDATA[<h2>1. 格式化打印MAC地址</h2>

<pre><code>u_int8_t mac[6] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
printk("%pM\n", mac);
/* 01:02:03:04:05:06 */
</code></pre>

<h2>2. 格式化打印IP地址</h2>

<pre><code>u_int32_t ip = ((1 &lt;&lt; 24) + (2 &lt;&lt; 16) + (3 &lt;&lt; 8) + 4);
/* 默认根据网络字节序打印 */
printk("%pI4\n", &amp;ip);
/* 1.2.3.4 */   
</code></pre>

<h2>2. 格式化打印IPv6地址</h2>

<pre><code>struct in6_addr ipv6 = IN6ADDR_LINKLOCAL_ALLNODES_INIT;
printk("%pI6c\n", &amp;ipv6);
/* ff02::1 */       
</code></pre>

<p><a href="http://www.kernel.org/doc/Documentation/printk-formats.txt">http://www.kernel.org/doc/Documentation/printk-formats.txt</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LINUX 进程内核通信]]></title>
    <link href="http://spiritbook.github.com/blog/2012/08/10/kernel-userspace-communication/"/>
    <updated>2012-08-10T20:44:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/08/10/kernel-userspace-communication</id>
    <content type="html"><![CDATA[<h2>1. netlink socket</h2>

<p>netlink socekt是一种用于在内核态和用户态进程之间进行数据传输的特殊的IPC。它通过为内核模块提
供一组特殊的API，并为用户程序提供了一组标准的socket接口的方式，实现了一种全双工的通讯连接。
类似于TCP/IP 中使用AF_INET 地址族一样，netlink socket使用地址族AF_NETLINK。
内核头文件</p>

<pre><code>#include &lt;linux/netlink.h&gt;
#include &lt;net/netlink.h&gt;
#include 
</code></pre>

<p>进程头文件</p>

<pre><code>#include &lt;linux/netlink.h&gt;
</code></pre>

<p>  A. 添加新的netlink类型 <br>
  B. 使用通用netlink类型通信(generic netlink)</p>

<h2>2. 系统调用</h2>

<h2>3. ioctl接口</h2>

<h2>4. proc fs</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用github创建blog]]></title>
    <link href="http://spiritbook.github.com/blog/2012/07/23/octopress/"/>
    <updated>2012-07-23T05:42:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/07/23/octopress</id>
    <content type="html"><![CDATA[<p>code6同学很早就用github搞了一个博客，<a href="http://code6.github.com/">猛击这里</a> <p>
今天根据教程试了一下，发现在ubuntu下还是略有不同。本菜使用ubuntu10.04，大致需要操作如下。<p></p>

<h2>0.略过github账号申请过程。</h2>

<h2>1. 安装<a href="https://rvm.io/">rvm</a></h2>

<pre><code>$ curl https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable
</code></pre>

<h2>2. 修改环境变量<p></h2>

<pre><code>[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm"
source ~/.bashrc
</code></pre>

<p>在~/.bashrc中添加如上字眼，如果是root用户，需要将$HOME/.rvm替换成/usr/local/rvm<p></p>

<h2>3. 安装ruby,rubygems</h2>

<pre><code>rvm install 1.9.2 &amp;&amp; rvm use 1.9.2
rvm rubygems latest
</code></pre>

<h2>4.下载octopress</h2>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
cd octopress
</code></pre>

<h2>5.安装bundler</h2>

<pre><code>gem install bundler
bundle install
</code></pre>

<h2>6.生成模板文件</h2>

<pre><code>rake install
</code></pre>

<h2>7.发布到github</h2>

<p>先需要在github中创建<b>yourname</b>.github.com的repository<p>
设定github pages</p>

<pre><code>rake setup_github_pages
</code></pre>

<p>输入git@github.com:<b>yourname/yourname</b>.github.com.git<p>
建立并发布<p></p>

<pre><code>rake generate
rake deploy
</code></pre>

<h2>8.将source也加入git</h2>

<pre><code>git add .
git commit -m 'initial source commit'
git push origin master
</code></pre>

<h2>9.创建新文章</h2>

<pre><code>rake new_post["how-to-install-octopress"]
</code></pre>

<h2>A.支持中文显示</h2>

<p>文章makrdown保存为无bom的utf-8即可。<p></p>

<h2>B.rake generate错误1</h2>

<pre><code>in 'require': no such file to load -- openssl (LoadError)
</code></pre>

<p>原因:本地是root用户，路径不对。解决方法:</p>

<pre><code>rvm reinstall 1.9.2 --with-openssl-dir=/usr/local/rvm
</code></pre>

<h2>C.本地预览</h2>

<pre><code>rake preview
</code></pre>

<p>浏览器中输入http://localhost:4000</p>

<h2>附录(参考链接)</h2>

<ol>
<li><a href="http://mrzhang.me/blog/blog-equals-github-plus-octopress.html">Blog = GitHub + Octopress</a><p></li>
<li><a href="http://lyhdev.com/note:octopress">Octopress: a blogging framework for hackers</a><p></li>
<li><a href="http://www.yangzhiping.com/tech/octopress.html">Ruby开源项目介绍(1)：octopress——像黑客一样写博客</a><p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[chinese]]></title>
    <link href="http://spiritbook.github.com/blog/2012/07/23/chinese/"/>
    <updated>2012-07-23T01:46:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/07/23/chinese</id>
    <content type="html"><![CDATA[<p>中文中文中文</p>
汉字汉字汉字</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://spiritbook.github.com/blog/2012/07/22/hello-world/"/>
    <updated>2012-07-22T22:09:00+08:00</updated>
    <id>http://spiritbook.github.com/blog/2012/07/22/hello-world</id>
    <content type="html"><![CDATA[<p> code </p>


<p><code>printf("helloworld");</code></p>

<br />


<p><img src="http://spiritbook.github.com/images/ali.jpg" alt="Ali" /></p>

<pre><code>int a, b;
printf("%d\n", a + b);
</code></pre>
]]></content>
  </entry>
  
</feed>
